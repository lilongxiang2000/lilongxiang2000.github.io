[{"title":"排序算法总结","url":"/2022/04/29/Summary-of-Sorting-Algorithms/","content":"常见排序算法总结：冒泡排序、选择排序、插入排序、归并排序、快速排序，其代码均采用 JavaScript 实现。（待补充）\n冒泡排序冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n\n\n\n最差复杂性\n最优复杂性\n平均复杂性\n空间复杂性\n\n\n\n\n\n\n\n\n\n算法描述\n比较相邻的元素。如果第一个比第二个大，就交换它们两个；\n对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对；\n针对所有的元素重复以上的步骤，除了最后一个；\n重复步骤 1~3，直到排序完成。\n\n代码实现function bubbleSort(arr) {  const n = arr.length  for (let i = 0; i &lt; n-2; i++) {    for (let j = 0; j &lt; n-1-i; j++) {      if (arr[j] &gt; arr[j+1]) {        [arr[j], arr[j+1]] = [arr[j+1], arr[j]]      }    }  }  return arr}\n\n代码优化在数据完全有序的时有最优时间复杂度，为 。其他情况下，几乎总是 。因此，算法在数据基本有序的情况下，性能最好。要使算法在最佳情况下有  复杂度，需要做一些改进，在每一轮循环中记录是否有发生给交换，当前一轮没有进行交换时，说明数组已经有序，没有必要再进行下一轮的循环了，直接返回。\nfunction bubbleSort(arr) {  const n = arr.length  let swapped = false  for (let i = 0; i &lt; n-2; i++) {    for (let j = 0; j &lt; n-1-i; j++) {      if (arr[j] &gt; arr[j+1]) {        swapped = true        [arr[j], arr[j+1]] = [arr[j+1], arr[j]]      }    }    // 若未进行过交换，说明arr已经是有序的    if (!swapped) return arr  }  return arr}\n\n选择排序选择排序（Selection sort）是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度，可以认为选择排序是冒泡排序的一种改进。\n\n\n\n最差复杂性\n最优复杂性\n平均复杂性\n空间复杂性\n\n\n\n\n\n\n\n\n\n算法描述\n首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；\n然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；\n重复上述过程直到所有元素均排序完毕。\n\n代码实现function selectSort(arr) {  const n = arr.length  for (let i = 0; i &lt; n - 1; i++) {    let minIndex = i    for (let j = i + 1; j &lt; n; j++) {      if (arr[j] &lt; arr[minIndex]) {        minIndex = j      }    }    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]  }  return arr}\n\n插入排序插入排序（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\n\n\n\n最差复杂性\n最优复杂性\n平均复杂性\n空间复杂性\n\n\n\n\n\n\n\n\n\n算法描述\n把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的；\n从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置；\n重复上述过程直到最后一个元素被插入有序子数组中。\n\n代码实现function insertSort(arr) {  const n = arr.length  for (let i = 0; i &lt; n; i++) {    for (let j = i; i &gt; 0; j--) {      if (arr[j] &lt; arr[j - 1]) {        [arr[j], arr[j-1]] = [arr[j-1], arr[j]]      } else break    }  }  return arr}\n\n归并排序归并排序（Merge sort）是创建在归并操作上的一种有效的排序算法，效率为  。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。\n\n\n\n最差复杂性\n最优复杂性\n平均复杂性\n空间复杂性\n\n\n\n\n\n\n\n\n\n算法描述\n申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；\n设定两个指针，最初位置分别为两个已经排序序列的起始位置；\n比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；\n重复步骤3直到某一指针到达序列尾；\n将另一序列剩下的所有元素直接复制到合并序列尾。\n\n代码实现function mergeSort(arr) {  function merge(left, right) {    let result = []    while (left.length &amp;&amp; right.length) {      if (left[0] &lt; right[0]) {        result.push(left.shift())      } else result.push(right.shift())    }    // left, right 长度不一时防止有剩余    return result.concat(left, right)  }  if (arr.length &lt;= 1) return arr  let middle = arr.length &gt;&gt; 1  let left   = arr.slice(0, middle)  let right  = arr.slice(middle)  return merge(mergeSort(left), mergeSort(right))}\n\n快速排序快速排序是一个知名度极高的排序算法，其对于大数据的优秀排序性能和相同复杂度算法中相对简单的实现使它注定得到比其他算法更多的宠爱。\n\n\n\n最差复杂性\n最优复杂性\n平均复杂性\n空间复杂性\n\n\n\n\n\n\n不定，此处为 \n\n\n算法描述\n挑选基准值：从数列中挑出一个元素，称为“基准”（pivot）；\n分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成；\n递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。\n\n代码实现function quickSort(arr) {  function qsort(arr, left, right) {    if (left &gt;= right) return    let pivot = partition(arr, left, right) //将数组分为两部分    qsort(arr, left, pivot-1)               //递归排序左子数组    qsort(arr, pivot+1, right)              //递归排序右子数组  }  function partition(arr, left, right){    let pivot = arr[left]    while (left &lt; right) {      while (left &lt; right &amp;&amp; arr[right] &gt;= pivot) {        --right      }      arr[left] = arr[right] //交换比基准大的记录到左端      while (left &lt; right &amp;&amp; arr[left] &lt;= pivot) {        ++left;      }      arr[right] = arr[left] //交换比基准小的记录到右端    }    arr[left] = pivot    return left  }  qsort(arr, 0, arr.length-1)}\n","tags":["JavaScript","算法"]},{"title":"Math.sqrt 是如何实现的","url":"/2022/02/10/How-Math-sqrt-works/","content":"实现原理其原理很简单（牛顿迭代法），求  即为求函数  的根，其导函数为  。随意取  过点  作切线，切线的斜率为 ，切线与  轴的交点为  ，将该点  的值作为新的  ，重复上面计算，若干次后精确度就能达到很高。\n我们来验证下，假设 ， 精确值为 ，现在随便取 ，通过下表可看到，经过四次计算后精确度已经达到了小数点后 11 位。\n\n\n\n\n切线方程与  轴交点\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n代码实现function sqrt(n) {  // 随意取结果的近似值，上一次的计算结果  let result = n/2, last  do { // 通过判断两次结果的差值控制精确度    last = result // 保存上一次的计算结果    result = (result + n/result) / 2 // 新的结果  } while( Math.abs(result-last) &gt; 0.01 )  return result}\n\n\n\n\n\n\n","tags":["JavaScript","函数实现"]}]